## 实验二 Bomb Lab 讲解

该实验主要考察 CSAPP 书中第三章的相关内容，例如寄存器的概念和使用、汇编指令的理解和运用。

该实验的主要目的是依据对程序在计算机中的数据存储、函数调用等在汇编指令上的体现和对于函数栈帧的理解，进而使用调试工具分析可执行程序。

## 结果演示

该实验需要在可执行程序 `bomb` 依次输入不同的字符串，从而破解不同的“炸弹”。

通过给定 `bomb` 程序参数，可以将输入重定位到文件中，我的验证方式为：将题解写入到文本文件 `solution.txt` 。

脚本内容如下：

```bash
#!/bin/bash

echo -e "----solution.txt----"
./bomb solution.txt
echo -e "--------------------\n"
```

文本文件 `solution.txt` 的内容如下：

```txt
Border relations with Canada have never been better.
1 2 4 8 16 32
7 327
7 0
9?>567
4 3 2 1 6 5 
```

脚本的运行结果如下：

```bash
----solution.txt----
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
Good work!  On to the next...
Congratulations! You've defused the bomb!
--------------------
```

可以看到我已经满足了实验的所有要求，成功完成了所有实验内容。 

## 过程讲解

在完成指定的阶段总结写在这里：

- Phase 1：匹配输入的字符串与指定地址的字符串，查看该地址处的字符串即可。
- Phase 2：要求输入可以切割为六个数字，并且要求相邻数字之间的关系为倍增。
- Phase 3：要求输入可以切割为两个数字，并根据第一个数字，限定第二个数字的值。
- Phase 4：要求输入可以切割为两个数字，子函数func4限定第一个数值的一个合法值为7，第二个为0。
- Phase 5：将输入的六个字符的ASCII码的低四位作为偏移从指定字符串中取出字符组合成目标字符串。
- Phase 6：要求输入六个数字，使得链表按照输入数字对7取模顺次进行排列之后，链表元素递减。

### Phase 1

```asm
Dump of assembler code for function phase_1:
   0x0000000000400ee0 <+0>:	sub    $0x8,%rsp
   # 将内存地址0x402400存放的数据作为函数string_not_equal的第二个参数 
   0x0000000000400ee4 <+4>:	mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:	callq  0x401338 <strings_not_equal>
   # 如果返回值为零则通过
   0x0000000000400eee <+14>:	test   %eax,%eax
   0x0000000000400ef0 <+16>:	je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:	callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:	add    $0x8,%rsp
   0x0000000000400efb <+27>:	retq   
End of assembler dump.
```

```bash
(gdb) disas phase_1		// 显示汇编代码
(gdb) break phase_1		// 设置断点
(gdb) run							// 运行至 phase_1处
(gdb) stepi						// 进行单步调试
(gdb) info r					// 查看寄存器的值
(gdb) x/s 0x402400		// 以字符串形式显示指定地址位置的数据
```

函数phase的参数存放在 `%edi` ，此寄存器在调用`string_not_equal`之前未改变，与 `%esi` 分别作为`sne`的第一个参数和第二个参数。使用`GDB`查看 `0x402400` 内存所存储的字符串即可验证。验证后可以知道`sne`函数的作用是如果两个字符串相同则返回0，否则返回1。该题的解法即为内存中的字符串。

`x/s 0x402400` 

`0x402400:	"Border relations with Canada have never been better."` 

### Phase 2

```asm
Dump of assembler code for function phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   # 开辟栈空间，将栈顶地址给 %rsi，调用 read_six_numbers，此时 %edi 为 phase_2的参数input
   # 比较栈顶的数据与1的关系，如果相等则跳过炸弹，到 <phase_2+52> 去执行
   # 因此分析函数 rsn 对栈空间的处理
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
   # 栈帧中的数据分布
   # ----------> stack top
   # 6 5 4 3 2 1
   
   # 第一个炸弹点，如果第一个数不是 1，则爆炸
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>

	 # 依次将前一个数值乘以二作为后一个数值，直到最后一个数为止，如果其间有数不满足二倍关系就爆炸
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   # %rbp 中的地址为第六个数的地址+4，每次选择下一个数的时候都检查是否比完六个数
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   
   # 第二个数的地址存入 %rbx，%rbp 未知
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq   
End of assembler dump.
```

```asm
Dump of assembler code for function read_six_numbers:
	 # 开辟栈空间
	 # 将 input 作为 sscanf() 的第一个参数
	 # 内存 0x4025c3 处字符串为 "%d %d %d %d %d %d" 作为第二个参数
	 # 依次将 phase_2 函数栈帧从栈顶向上的24个字节的地址分别存储在
	 # %rdx %rcx %r8 %r9 和 read_six_numbers 的栈帧中的顶部的32字节中
	 # 作为 sscanf 的后面六个参数以顺序接收 input 的六个整型数据的输入
	 # sscanf 的返回值为成功赋值的字段数 如果 input 中数字少于 6 个则爆炸
   0x000000000040145c <+0>:	    sub    $0x18,%rsp
   0x0000000000401460 <+4>:	    mov    %rsi,%rdx
   0x0000000000401463 <+7>:	    lea    0x4(%rsi),%rcx
   0x0000000000401467 <+11>:	lea    0x14(%rsi),%rax
   0x000000000040146b <+15>:	mov    %rax,0x8(%rsp)
   0x0000000000401470 <+20>:	lea    0x10(%rsi),%rax
   0x0000000000401474 <+24>:	mov    %rax,(%rsp)
   0x0000000000401478 <+28>:	lea    0xc(%rsi),%r9
   0x000000000040147c <+32>:	lea    0x8(%rsi),%r8
   0x0000000000401480 <+36>:	mov    $0x4025c3,%esi
   0x0000000000401485 <+41>:	mov    $0x0,%eax
   # 将 input 作为第一个参数，如果 %eax 中数据大于 5，则跳过炸弹
   0x000000000040148a <+46>:	callq  0x400bf0 <__isoc99_sscanf@plt>
   0x000000000040148f <+51>:	cmp    $0x5,%eax
   0x0000000000401492 <+54>:	jg     0x401499 <read_six_numbers+61>
   
   0x0000000000401494 <+56>:	callq  0x40143a <explode_bomb>
   0x0000000000401499 <+61>:	add    $0x18,%rsp
   0x000000000040149d <+65>:	retq   
End of assembler dump.
```

使用`read_six_numbers`函数操纵`phase_2`的栈帧，并将字符串中的数据解析到`phase_2`的栈帧中。

### Phase 3

```asm
Dump of assembler code for function phase_3:
	 # 栈帧 24 字节
	 # -0x18-｜-0x14-｜-0x10-｜-0xc-｜-0x8-｜-0x4-｜-0x0- --> Stack Top
	 #                         rcx    rdx
   # esi : 0x4025cf :       "%d %d"
   # sscanf(input, "%d %d", 0x8, 0xc);
   # 如果输入的数字个数小于1，爆炸
   0x0000000000400f43 <+0>:     sub    $0x18,%rsp
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
   0x0000000000400f5b <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    callq  0x40143a <explode_bomb>
   # 比较输入的第一个数和7的大小，如果 第一个数大于 7 则爆炸
   # 0x402470 ： 0x400f7c
   # 跳转的位置 0x400f7c + R[%rax] * 8
   # (rax) = 8,9,10,11...
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax
   # 根据 %rax 的值进行跳转，并对 %eax 赋予不同的值
   # (gdb) p /x *(0x402470+0) -> %eax = 0, 0xc(%rsp) = 0xcf(207)
   # $20 = 0x400f7c
   # (gdb) p /x *(0x402470+8) -> %eax = 1, 0xc(%rsp) = 0x137(311)
   # $21 = 0x400fb9
   # (gdb) p /x *(0x402470+16) -> %eax = 2, 0xc(%rsp) = 0x2c3(707)
   # $22 = 0x400f83
   # (gdb) p /x *(0x402470+24) -> %eax = 3, 0xc(%rsp) = 0x100(256)
   # $23 = 0x400f8a
   # (gdb) p /x *(0x402470+32) -> %eax = 4, 0xc(%rsp) = 0x185(389)
   # $24 = 0x400f91
   # (gdb) p /x *(0x402470+40) -> %eax = 5, 0xc(%rsp) = 0xce(206)
   # $25 = 0x400f98
   # (gdb) p /x *(0x402470+48) -> %eax = 6, 0xc(%rsp) = 0x2aa(682)
   # $26 = 0x400f9f
   # (gdb) p /x *(0x402470+56) -> %eax = 7, 0xc(%rsp) = 0x147(327)
   # $27 = 0x400fa6
   0x0000000000400f75 <+50>:    jmpq   *0x402470(,%rax,8)
   
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   
   0x0000000000400fad <+106>:   callq  0x40143a <explode_bomb>
   
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax
   
   # 比较第二个数和 %eax 中的值，如果相等则成功
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   callq  0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   retq   
End of assembler dump.
```

该题通过对输入的数据进行检验和输入数据的关系进行映射来设置炸弹。

### Phase 4

```asm
Dump of assembler code for function phase_4:
   # 栈帧 24 字节
   # 栈顶的两地址分别作为第一个参数和第二个参数传入 sscanf
   # 0x4025cf:	"%d %d"
   # 接收两个数字，分别存储在 0x8(%rsp)、0xc(%rsp)
   0x000000000040100c <+0>:	  sub    $0x18,%rsp
   0x0000000000401010 <+4>:	  lea    0xc(%rsp),%rcx
   0x0000000000401015 <+9>:	  lea    0x8(%rsp),%rdx
   0x000000000040101a <+14>:	mov    $0x4025cf,%esi
   0x000000000040101f <+19>:	mov    $0x0,%eax
   0x0000000000401024 <+24>:	callq  0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000401029 <+29>:	cmp    $0x2,%eax
   0x000000000040102c <+32>:	jne    0x401035 <phase_4+41>
   # 第一个参数要求小于等于 0xe
   0x000000000040102e <+34>:	cmpl   $0xe,0x8(%rsp)
   0x0000000000401033 <+39>:	jbe    0x40103a <phase_4+46>
   0x0000000000401035 <+41>:	callq  0x40143a <explode_bomb>
   # 调用func4(arg_1,0,14)
   0x000000000040103a <+46>:	mov    $0xe,%edx
   0x000000000040103f <+51>:	mov    $0x0,%esi
   0x0000000000401044 <+56>:	mov    0x8(%rsp),%edi
   0x0000000000401048 <+60>:	callq  0x400fce <func4>
   # 如果返回值不为零，则爆炸
   0x000000000040104d <+65>:	test   %eax,%eax
   0x000000000040104f <+67>:	jne    0x401058 <phase_4+76>
   # 第二个参数为零，则通关
   0x0000000000401051 <+69>:	cmpl   $0x0,0xc(%rsp)
   0x0000000000401056 <+74>:	je     0x40105d <phase_4+81>
   0x0000000000401058 <+76>:	callq  0x40143a <explode_bomb>
   0x000000000040105d <+81>:	add    $0x18,%rsp
   0x0000000000401061 <+85>:	retq   
End of assembler dump.
```

```asm
Dump of assembler code for function func4:
   # -------edi-|esi|-edx-                        
   # func4(arg1, 0 , 14)
   # 栈帧 8 字节
   # eax = [(arg3 - arg2) >h> 31 + (arg3 - arg2)] >a> 1  = 7
   # ecx = 7 + arg2*1
   0x0000000000400fce <+0>:	  sub    $0x8,%rsp
   0x0000000000400fd2 <+4>:	  mov    %edx,%eax
   0x0000000000400fd4 <+6>:	  sub    %esi,%eax
   0x0000000000400fd6 <+8>:	  mov    %eax,%ecx
   0x0000000000400fd8 <+10>:	shr    $0x1f,%ecx
   0x0000000000400fdb <+13>:	add    %ecx,%eax
   0x0000000000400fdd <+15>:	sar    %eax
   0x0000000000400fdf <+17>:	lea    (%rax,%rsi,1),%ecx
   # NOW : ecx = 7, eax = 7
   
   # if (%ecx 小于等于 %edi){							
   # 		%eax = 0;
   #		if (%ecx 大于等于 %edi) return 0;
   # }
   # else{ // 第一个数大于 7
   # 		%edx = %rcx - 1;
   #		func4(%edi, %esi, %edx);
   # }
   0x0000000000400fe2 <+20>:	cmp    %edi,%ecx
   0x0000000000400fe4 <+22>:	jle    0x400ff2 <func4+36>
   0x0000000000400fe6 <+24>:	lea    -0x1(%rcx),%edx
   0x0000000000400fe9 <+27>:	callq  0x400fce <func4>
   0x0000000000400fee <+32>:	add    %eax,%eax
   0x0000000000400ff0 <+34>:	jmp    0x401007 <func4+57>
   0x0000000000400ff2 <+36>:	mov    $0x0,%eax
   0x0000000000400ff7 <+41>:	cmp    %edi,%ecx
   0x0000000000400ff9 <+43>:	jge    0x401007 <func4+57>
   0x0000000000400ffb <+45>:	lea    0x1(%rcx),%esi
   0x0000000000400ffe <+48>:	callq  0x400fce <func4>
   0x0000000000401003 <+53>:	lea    0x1(%rax,%rax,1),%eax
   0x0000000000401007 <+57>:	add    $0x8,%rsp
   0x000000000040100b <+61>:	retq   
End of assembler dump.
```

该题使用调用函数`func4`得到一个返回值为0的条件，即第一个参数为`7`。返回`phase_4`之后验证第二个参数为0，则通过。

### Phase 5

```asm
Dump of assembler code for function phase_5:
   0x0000000000401062 <+0>: 	push   %rbx
   0x0000000000401063 <+1>:	  sub    $0x20,%rsp
   # 经过验证如果输入字符串长度不为 6 则止步于此
   0x0000000000401067 <+5>:	  mov    %rdi,%rbx
   # 堆栈保护
   0x000000000040106a <+8>:	  mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:	mov    %rax,0x18(%rsp)
   
   0x0000000000401078 <+22>:	xor    %eax,%eax
   0x000000000040107a <+24>:	callq  0x40131b <string_length>
   0x000000000040107f <+29>:	cmp    $0x6,%eax
   0x0000000000401082 <+32>:	je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:	callq  0x40143a <explode_bomb>
   0x0000000000401089 <+39>:	jmp    0x4010d2 <phase_5+112>
   # 截取输入字符的 ASCII 码的低四位作为偏移量
   0x000000000040108b <+41>:	movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f <+45>:	mov    %cl,(%rsp)
   0x0000000000401092 <+48>:	mov    (%rsp),%rdx
   0x0000000000401096 <+52>:	and    $0xf,%edx
   # 将转换的字符放到栈帧中 rsp + 0x10 ~ 0x15
   0x0000000000401099 <+55>:	movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:	mov    %dl,0x10(%rsp,%rax,1)
   # 循环处理六个字符
   0x00000000004010a4 <+66>:	add    $0x1,%rax
   0x00000000004010a8 <+70>:	cmp    $0x6,%rax
   0x00000000004010ac <+74>:	jne    0x40108b <phase_5+41>
   
   # 将所有字符处理完毕，将新生成的字符串末尾添加一个字节的0
   0x00000000004010ae <+76>:	movb   $0x0,0x16(%rsp)
   # 0x40245e : "flyers"
   # ---------f---l---y---e---r---s-----
   # ---------9---f---e---5---6---7-----
   # 0x40245e : "maduiersnfotvbyl...
   0x00000000004010b3 <+81>:	mov    $0x40245e,%esi
   0x00000000004010b8 <+86>:	lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:	callq  0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:	test   %eax,%eax
   # 比较新生成的字符串与 "flyers" 一致则跳过炸弹
   0x00000000004010c4 <+98>:	je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:	callq  0x40143a <explode_bomb>
   0x00000000004010cb <+105>:	nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 <+110>:	jmp    0x4010d9 <phase_5+119>
   # 清空 eax
   0x00000000004010d2 <+112>:	mov    $0x0,%eax
   0x00000000004010d7 <+117>:	jmp    0x40108b <phase_5+41>
   # 检查栈是否受到破坏，未被破坏通关
   0x00000000004010d9 <+119>:	mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:	xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:	je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:	callq  0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:	add    $0x20,%rsp
   0x00000000004010f2 <+144>:	pop    %rbx
   0x00000000004010f3 <+145>:	retq   
End of assembler dump.
```

该题通过对字符串的解密进行破解，将输入字符的ASCII的低四位作为偏移，从指定的字符串中取出相应的字符匹配目标字符串得解。

## Phase 6

```asm
Dump of assembler code for function phase_6:
   # 被调用者保存寄存器
   0x00000000004010f4 <+0>:	  push   %r14
   0x00000000004010f6 <+2>:	  push   %r13
   0x00000000004010f8 <+4>:	  push   %r12
   0x00000000004010fa <+6>:	  push   %rbp
   0x00000000004010fb <+7>:	  push   %rbx
   # 栈帧 80 字节
   0x00000000004010fc <+8>:	  sub    $0x50,%rsp
   # 读取 六个数字 并顺次存放在栈的顶部
   # 所有的六个数字都要小于等于 6
   # 并且互不相等
   
   # int check_in(int *num){
   #     int check = 0;
   #     while(1){
   #         check += 1;
   #         if (check == 6)  break;
   #         if (*num > 6) return BOMB;
   #         int i = check;
   #         while(1){
   #             if (*(num+i) == *num) return BOMB;
   #             i += 1;
   #             if (i > 5) break;
   #         }
   #         num += 1;
   #     } 
   #     return 0;
   # }
   0x0000000000401100 <+12>:	mov    %rsp,%r13
   0x0000000000401103 <+15>:	mov    %rsp,%rsi
   0x0000000000401106 <+18>:	callq  0x40145c <read_six_numbers>
   
   # --------------------------------------------
   # 循环开始，计数器在 r12d
   0x000000000040110b <+23>:	mov    %rsp,%r14
   0x000000000040110e <+26>:	mov    $0x0,%r12d
   # ============================================
   
   # --------------------------------------------
   # 限制目标值小于等于6
   0x0000000000401114 <+32>:	mov    %r13,%rbp
   0x0000000000401117 <+35>:	mov    0x0(%r13),%eax
   0x000000000040111b <+39>:	sub    $0x1,%eax
   0x000000000040111e <+42>:	cmp    $0x5,%eax
   0x0000000000401121 <+45>:	jbe    0x401128 <phase_6+52>
   0x0000000000401123 <+47>:	callq  0x40143a <explode_bomb>
   # =============================================
   
   # ---------------------------------------------
   # 计数器累加，计数器等于6，结束循环
   0x0000000000401128 <+52>:	add    $0x1,%r12d
   0x000000000040112c <+56>:	cmp    $0x6,%r12d
   0x0000000000401130 <+60>:	je     0x401153 <phase_6+95>
   # =============================================
   
   # ---------------------------------------------
   # 将计数器作为偏移量，取得栈顶偏移位置数，作为目标值
   # 限制该目标值与上一个目标值不相同
   0x0000000000401132 <+62>:	mov    %r12d,%ebx
   0x0000000000401135 <+65>:	movslq %ebx,%rax
   0x0000000000401138 <+68>:	mov    (%rsp,%rax,4),%eax
   0x000000000040113b <+71>:	cmp    %eax,0x0(%rbp)
   0x000000000040113e <+74>:	jne    0x401145 <phase_6+81>
   0x0000000000401140 <+76>:	callq  0x40143a <explode_bomb>
   # =============================================
   
   # ---------------------------------------------
   # 如果计数器为不是 4，也就是说，后面还有不只一个数，则回去比较后续的数是否与目标值相等
   # 把基准位置向上移动四个字节
   0x0000000000401145 <+81>:	add    $0x1,%ebx
   0x0000000000401148 <+84>:	cmp    $0x5,%ebx
   0x000000000040114b <+87>:	jle    0x401135 <phase_6+65>
   0x000000000040114d <+89>:	add    $0x4,%r13
   0x0000000000401151 <+93>:	jmp    0x401114 <phase_6+32>
   # ======================================================
   
   
   
   
   
   
   #=======================================================
   # 等价代码 : 将每一个数字对 7 取模。
   # int loop2(int *num){
   #     int *tail = num + 6;
   #     int mod = 7;
   #     *num = mod - *num;
   #     while(1){
   #         if ((num + 1) != tail){
   #             *(num + 1) = mod - *(num + 1); 
   #         }else{
   #             break;
   #         }   
   #     }   
   # }
   #======================================================
   0x0000000000401153 <+95>:	lea    0x18(%rsp),%rsi
   0x0000000000401158 <+100>:	mov    %r14,%rax
   0x000000000040115b <+103>:	mov    $0x7,%ecx
   0x0000000000401160 <+108>:	mov    %ecx,%edx
   0x0000000000401162 <+110>:	sub    (%rax),%edx
   0x0000000000401164 <+112>:	mov    %edx,(%rax)
   0x0000000000401166 <+114>:	add    $0x4,%rax
   0x000000000040116a <+118>:	cmp    %rsi,%rax
   0x000000000040116d <+121>:	jne    0x401160 <phase_6+108>
   # rsp = 0x7fffffffea80
   # (gdb) p *(0x7fffffffea80+0)
   # $15 = 6
   # (gdb) p *(0x7fffffffea80+4)
   # $16 = 5
   # (gdb) p *(0x7fffffffea80+8)
   # $17 = 4
   # (gdb) p *(0x7fffffffea80+12)
   # $18 = 3
   # (gdb) p *(0x7fffffffea80+16)
   # $19 = 2
   # (gdb) p *(0x7fffffffea80+20)
   # $20 = 1
   # (gdb) p *(0x7fffffffea80+24)
   #=======================================================
   
   
   
   
   # 重排链表，使用[7-num[i]-1]作为序号
   #=======================================================
   # si = 0; si 作为计数器 i
   0x000000000040116f <+123>:	mov    $0x0,%esi
   0x0000000000401174 <+128>:	jmp    0x401197 <phase_6+163>
   
   # 将 cx 中数据作为序号
   # 比较 7 - num1 和 2
   0x0000000000401176 <+130>:	mov    0x8(%rdx),%rdx
   0x000000000040117a <+134>:	add    $0x1,%eax					
   0x000000000040117d <+137>:	cmp    %ecx,%eax					
   0x000000000040117f <+139>:	jne    0x401176 <phase_6+130>
   0x0000000000401181 <+141>:	jmp    0x401188 <phase_6+148>		# ax = 7-num1
   
   0x0000000000401183 <+143>:	mov    $0x6032d0,%edx
   0x0000000000401188 <+148>:	mov    %rdx,0x20(%rsp,%rsi,2)		#
   0x000000000040118d <+153>:	add    $0x4,%rsi
   0x0000000000401191 <+157>:	cmp    $0x18,%rsi
   0x0000000000401195 <+161>:	je     0x4011ab <phase_6+183>
   
   # 依次取得 栈顶的输入数据 存在 cx 中
   # 如果小于等于1，否则，按照数值索引
   0x0000000000401197 <+163>:	mov    (%rsp,%rsi,1),%ecx			# cx = 7-num1
   0x000000000040119a <+166>:	cmp    $0x1,%ecx
   0x000000000040119d <+169>:	jle    0x401183 <phase_6+143>
   0x000000000040119f <+171>:	mov    $0x1,%eax					# ax = 1
   0x00000000004011a4 <+176>:	mov    $0x6032d0,%edx
   0x00000000004011a9 <+181>:	jmp    0x401176 <phase_6+130>
   #=======================================================
   
   #=======================================================
   0x00000000004011ab <+183>:	mov    0x20(%rsp),%rbx 
   # bx = 0x6032d0+((7-num1)-1)*8
   0x00000000004011b0 <+188>:	lea    0x28(%rsp),%rax
   # (ax) = 0x000000006032f0
   0x00000000004011b5 <+193>:	lea    0x50(%rsp),%rsi
   # cx = 0x6032d0+((7-num1)-1)*8
   0x00000000004011ba <+198>:	mov    %rbx,%rcx
   # dx = 0x000000006032f0
   0x00000000004011bd <+201>:	mov    (%rax),%rdx  
   # (cx).next = (dx)
   0x00000000004011c0 <+204>:	mov    %rdx,0x8(%rcx)
   # ax += 0x8
   # (ax) = (ax).next
   0x00000000004011c4 <+208>:	add    $0x8,%rax
   # ?
   0x00000000004011c8 <+212>:	cmp    %rsi,%rax
   0x00000000004011cb <+215>:	je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:	mov    %rdx,%rcx
   0x00000000004011d0 <+220>:	jmp    0x4011bd <phase_6+201>
   #======================================================
   
   
   # 推测重排后的链表需要满足递减的关系
   #======================================================
   # 最后一个节点的next = null
   0x00000000004011d2 <+222>:	movq   $0x0,0x8(%rdx)
   # bp = 5
   0x00000000004011da <+230>:	mov    $0x5,%ebp
   # (ax) = (bx).next
   0x00000000004011df <+235>:	mov    0x8(%rbx),%rax
   # ax = (ax)
   0x00000000004011e3 <+239>:	mov    (%rax),%eax
   # 比较 ax 和 (bx),必须满足 (bx) >= ax
   0x00000000004011e5 <+241>:	cmp    %eax,(%rbx)
   0x00000000004011e7 <+243>:	jge    0x4011ee <phase_6+250>
   0x00000000004011e9 <+245>:	callq  0x40143a <explode_bomb>
   0x00000000004011ee <+250>:	mov    0x8(%rbx),%rbx
   0x00000000004011f2 <+254>:	sub    $0x1,%ebp
   0x00000000004011f5 <+257>:	jne    0x4011df <phase_6+235>
   #======================================================
   0x00000000004011f7 <+259>:	add    $0x50,%rsp
   0x00000000004011fb <+263>:	pop    %rbx
   0x00000000004011fc <+264>:	pop    %rbp
   0x00000000004011fd <+265>:	pop    %r12
   0x00000000004011ff <+267>:	pop    %r13
   0x0000000000401201 <+269>:	pop    %r14
   0x0000000000401203 <+271>:	retq   
End of assembler dump.
```







